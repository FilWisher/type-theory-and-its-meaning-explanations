\documentclass{amsart}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{dsfont}
\usepackage{multicol}
\usepackage{proof}
\usepackage{setspace}
\usepackage[usenames,dvipsnames,svgnames,table]{xcolor}
\usepackage{stmaryrd}

\newtheorem{thm}{Theorem}[section]
\newtheorem{prop}[thm]{Proposition}
\newtheorem{lem}[thm]{Lemma}
\newtheorem{cor}[thm]{Corollary}
\theoremstyle{definition}
\newtheorem{definition}[thm]{Definition}
\newtheorem{example}[thm]{Example}

\theoremstyle{remark}
\newtheorem{remark}[thm]{Remark}
\numberwithin{equation}{section}

\newcommand\isprop[1]{\ensuremath{#1\;\mathit{prop}}}
\newcommand\istrue[1]{\ensuremath{#1\;\mathit{true}}}
\newcommand\hyp[2]{\ensuremath{#1\ (#2)}}
\newcommand\ver[2]{\ensuremath{#1\in#2}}
\newcommand\reduce[2]{\ensuremath{#1\Rightarrow#2}}
\newcommand\naturals{\ensuremath{\mathbb{N}}}
\newcommand\suc[1]{\ensuremath{\mathsf{S}(#1)}}
\newcommand\natrec[3]{\ensuremath{\mathsf{rec}_\naturals(#1;#2;#3)}}
\newcommand\lfhyp[2]{\ensuremath{#1\ [#2]}}
\newcommand\prf[1]{\ensuremath{\mathsf{Prf}(#1)}}
\newcommand\MLLF{\textbf{MLLF}}
\newcommand\infers[2]{\ensuremath{#1\uparrow{\color{Gray}{#2}}}}
\newcommand\checks[2]{\ensuremath{#1\downarrow#2}}

\newcommand\type[1]{\ensuremath{#1:\mathit{type}}}
\newcommand\product[2]{\ensuremath{#1\&#2}}
\newcommand\pair[2]{\ensuremath{\langle #1,#2\rangle}}
\newcommand\fst[1]{\ensuremath{\mathsf{fst}(#1)}}
\newcommand\snd[1]{\ensuremath{\mathsf{snd}(#1)}}

\begin{document}
\title{Type theory and its meaning explanations}
\author{Jonathan Sterling}

\thanks{Thanks to Bob Harper, Peter Dybjer and Bengt Norstr\"om for invaluable
conversations that helped to clarify my understanding of the meaning
explanations for Martin-L\"of's Type Theory.}

% \address{AlephCloud Systems}
% \email{jon@jonmsterling.com}

\begin{abstract}
  At the heart of intuitionistic type theory lies an intuitive semantics called
  the ``meaning explanations''; crucially, when meaning explanations are taken as
  definitive for type theory, the core notion is no longer ``proof'' but
  ``verification''. Weâ€™ll explore how type theories of this sort arise naturally
  as enrichments of logical theories with further judgements, and contrast this
  with modern proof-theoretic type theories which interpret the judgements and
  proofs of logics, not their propositions and verifications.
\end{abstract}

\maketitle

\onehalfspacing

To start, we will consider the notion of a \emph{logical theory}; in my mind,
it starts with a species (or set) of judgements that can be proposed, asserted,
and (if they are evident) known.

\section{Judgements of a Logical Theory}

The basic forms of judgement for a logical theory will be \framebox{\isprop{P}} and
\framebox{\istrue{P}}; and what is $P$? It is a member of the species of terms,
which are made meaningful in the course of making the judgement
$\isprop{P}$ evident for a proposition $P$.

To each judgement is assigned a \emph{meaning explanation}, which explicates
the knowledge-theoretic content of the judgement. For a judgement
$\mathcal{J}$, a meaning explanation should be in the form:
\begin{quote}
  To know $\mathcal{J}$ is to know...
\end{quote}

The meaning of the judgement \isprop{P} is, then, as follows:
\begin{quote}
  To know \isprop{P} is to know that $P$ is a proposition, which is to know
  what counts as a direct verification of $P$.
\end{quote}

So if a symbol $P$ is taken to denote a proposition, we must know \emph{what
sort of thing} is to be taken as a direct verification of $P$, and this is by
definition. A ``direct verification'' is understood in constrast with an
``indirect verification'', which is to be thought of as a means or plan for
verifying the proposition. Now, the judgement \istrue{P} is only meaningful in
case we know \isprop{P} (this is called a presupposition). Then the meaning of
\istrue{P} is as follows:
\begin{quote}
  To know \istrue{P} is to have a verification of $P$.
\end{quote}

From the (implicit) presupposition \isprop{P}, we already know what counts as a
verification, so the meaning explanation is well-defined. Note that it is the
same to have a means or plan for verifying $P$ as to have a (direct)
verification; this follows from the fact that one may put into action a plan
for verifying $P$ and get out such a verification, and likewise, it is possible
to propound a plan of verification by appealing to an existing verification.

The judgements we have described so far are ``categorical'' in the sense that
they are made without assumption. We will need to define a further form of
judgement, which is called ``hypothetical'', and this is the judgement under
hypothesis \framebox{\hyp{\mathcal{J}}{\mathcal{J}_1,\dots,\mathcal{J}_n}}. And
its meaning explanation is as follows:

\begin{quote}
  To know the judgement \hyp{\mathcal{J}}{\mathcal{J}_1,\dots,\mathcal{J}_n} is to know the
  categorical judgement $\mathcal{J}$ when you know the judgements
  $\mathcal{J}_1,\dots,\mathcal{J}_n$.
\end{quote}


\section{Propositions}
Now that we have propounded and explained the minimal system of judgements for
a logical theory, let us populate it with propositions. First, we have falsity
$\bot$, and we wish to make \isprop{\bot} evident; to do this, we simply state
what counts as a direct verification of $\bot$, which is that there can be no
direct verification of $\bot$.

The next basic proposition is trivially true $\top$, and to make \isprop{\top}
evident, we state that a direct verification of $\top$ is trivial. The meaning
of $\top$ thus validates the judgement \istrue{\top}.

Next, let us define conjunction; in doing so, we will make evident the
hypothetical judgement \hyp{\isprop{P\land Q}}{\isprop{P},\isprop{Q}};
equivalently, we can display this as a rule of inference:
\[
  \infer{
    \isprop{P\land Q}
  }{
    \isprop{P} &
    \isprop{Q}
  }
\]

A direct verification of $P\land Q$ consists in a verification of $P$
and a verification of $Q$; this validates the assertion of the judgement
\hyp{\istrue{P\land Q}}{\istrue{P},\istrue{Q}}. Because it is a valid
inference, we can write it as an inference rule:
\[
  \infer{
    \istrue{P\land Q}
  }{
    \istrue{P} &
    \istrue{Q}
  }
\]

A direct verification of $P\lor Q$ may be got either from a verification
of $P$ or one of $Q$. From this definition we know \hyp{\isprop{P\lor
Q}}{\isprop{P},\isprop{Q}}, or
\[
  \infer{
    \isprop{P\lor Q}
  }{
    \isprop{P} &
    \isprop{Q}
  }
\]
The verification conditions of disjunction give
rise to two evident judgements \hyp{\istrue{P\lor Q}}{\istrue{P}} and
\hyp{\istrue{P\lor Q}}{\istrue{Q}}, which we can write as inference rules:
\begin{gather*}
  \infer{
    \istrue{P\lor Q}
  }{
    \istrue{P}
  }
  \qquad
  \infer{
    \istrue{P\lor Q}
  }{
    \istrue{Q}
  }
\end{gather*}

Finally, we must define the circumstances under which $P\supset Q$ is a
proposition (i.e.\ when \isprop{P\supset Q} is evident). And we intend this to
be under the circumstances that $P$ is a proposition, and also that $Q$ is a
proposition assuming that $P$ is true. In other words, \hyp{\isprop{P\supset
Q}}{\isprop{P}, \hyp{\isprop{Q}}{\istrue{P}}}, or
\[
  \infer{
    \isprop{P\supset Q}
  }{
    \isprop{P} &
    \hyp{\isprop{Q}}{\istrue{P}}
  }
\]

Now, to validate this judgement will be a bit more complicated than the
previous ones. But by unfolding the meaning explanations for hypothetical
judgement, proposition-hood and truth of a proposition, we arrive at the
following explanation:
\begin{quote}
  To know \hyp{\isprop{P\supset Q}}{\isprop{P},\hyp{\isprop{Q}}{\istrue{P}}} is
  to know what counts as a direct verification of $P\supset Q$ when one knows what
  counts as a direct verification of $P$, and, when one has such a verification, what
  counts as a direct verification of $Q$.
\end{quote}

(Note that unless \istrue{P}, it need not be evident that \isprop{Q}.) Now, if
this judgement is going to be made evident, then we must indeed come up with
what should count as a direct verification of $P\supset Q$ under the
assumptions described above.

And so to have a direct verification of $P\supset Q$ is to have a
verification of $Q$ assuming that one has one of $P$; this is the meaning of
implication, and it validates the judgement \hyp{\istrue{P\supset
Q}}{\hyp{\istrue{Q}}{\istrue{P}}} (elliding the hypothesis for
propositionhood), and may be written as an inference rule as follows:
\[
  \infer{
    \istrue{P\supset Q}
  }{
    \hyp{\istrue{Q}}{\istrue{P}}
  }
\]

\section{Judgements for Verifications}

So far, we have given judgements which circumscribe what it means to be a
proposition, and thence for each proposition, we have by definition a notion of
what should count as a verification of that proposition. And by definition, to
assert the judgement \istrue{P} is to assert that one has a verification of $P$,
but we have not considered any judgements which actually describe such
verifications.

It is a hallmark of Martin-L\"of's program to resolve the contradiction between
syntax and semantics not by choosing symbols over meanings or meanings over
symbols, but by endowing symbols with meaning in the course of knowing the
evident judgements. As such $P$ is a symbol, but when we assert \isprop{P} we
are saying that we know what proposition $P$ denotes.

A similar thing can be done with verifications themselves, by placing them in
the syntactic domain together with the propositional symbols. And then, we can
consider a judgement such as ``$M$ is a verification of $P$'', and in knowing
that judgement, we know what verification $M$ is meant to denote. In practice,
this judgement has been written in several ways:\\\medskip
\begin{tabular}{c|l}
  $M\in P$ & $M$ is an element of $P$\\
  $M\Vdash P$ & $M$ realizes $P$\\
  $P\ \llcorner\mathsf{ext}\; M\lrcorner$ & $P$ is witnessed by $M$
\end{tabular}

But they all mean the same thing, and so we will tentatively give the following
meaning explanation to this new judgement:
\begin{quote}
  * To know $\ver{M}{P}$ is to know that $M$ is a verification of $P$.
\end{quote}

But now that we have started to assign expressions to verifications, we must be
more careful about differentiating \emph{direct verifications} (which we will
call ``canonical'') from \emph{indirect verifications} (which we will call
``non-canonical''). So the domain of expressions must itself be accorded with a
notion of reduction to canonical form, and this corresponds with putting into
action a plan of verification in order to get an actual verification.
\begin{quote}
  To know \reduce{M}{M'} is to know that $M$ is an expression which reduces to
  a canonical form $M'$.
\end{quote}

Now, we can rewrite the previous meaning explanation as follows:
\begin{quote}
  To know \ver{M}{P} is to know an $M'$ such that \reduce{M}{M'} and $M'$ is a
  canonical (direct) verification of $P$.
\end{quote}

The meaning explanation for \isprop{P} must be accordingly modified to take
into account the computational behavior of the expression domain:
\begin{quote}
  To know \isprop{P} is to know a $P'$ such that \reduce{P}{P'} and $P'$ is a
  canonical proposition, which is to say, that one knows what counts as a
  canonical verification for $P'$.
\end{quote}

As an example, then, we will update the evidence of the assertion
\hyp{\isprop{P\supset Q}}{\isprop{P},\hyp{\isprop{Q}}{\isprop{P}}}. The meaning
of this, expanded into spoken language, is as follows:
\begin{quote}
  To know \hyp{\isprop{P\supset Q}}{\isprop{P},\hyp{\isprop{Q}}{\isprop{P}}} is
  to know what counts as a canonical verification of $P\supset Q$ under
  the circumstances that \reduce{P}{P'}, such one knows what counts as a
  canonical verification $P'$, and, if one has such a verification,
  \reduce{Q}{Q'} such that one knows what counts as a canonical verification of
  $Q'$.
\end{quote}

And this is evident, since we will say that a canonical verification of
$P\supset Q$ is an expression $\lambda x. E$ such that we know
\hyp{\ver{E}{Q}}{\ver{x}{P}}. This validates the assertion \hyp{\ver{\lambda
x.E}{P\supset Q}}{\hyp{\ver{E}{Q}}{\ver{x}{P}}}, written as an inference rule:
\[
  \infer{
    \ver{\lambda x.E}{P\supset Q}
  }{
    \hyp{\ver{E}{Q}}{\ver{x}{P}}
  }
\]

By the addition of this judgement, we have graduated from a logical theory to a
type theory, in the sense of \emph{Constructive Mathematics and Computer
Programming} (Martin-L\"of, 1979). In fact, we may dispense with the original
\istrue{P} form of judgement by \emph{defining} it in terms of the new
\ver{M}{P} judgement as follows:
\[
  \infer{
    \istrue{P}
  }{
    \ver{M}{P}
  }
\]

Further forms of judgement, such as assertions of equality between propositions
and verifications, may be added, as Martin-L\"of does. However, this is not
strictly necessary as they too may be defined in terms of the $\ver{M}{P}$
judgement in the presence of an \emph{equality} proposition; this is what is
done in Constable et al's Computational Type Theory, which has only one
primitive form of judgement.

[TODO] Give the syntax of full type theory and expand the meaning explanations
to account for new propositions and verifications


\section{Proof-Theoretic Type Theory}

\subsection{Analytic and Synthetic Judgement}

A synthetic judgement is one for which the experience of \emph{coming to know
it} necessarily results in the synthesis of some new information; on the other
hand, to know an \emph{analytic} judgement is to know it purely on the basis of
the information contained inside it. So analytic judgements are decidable,
since if they may become evident, it will be purely on the basis of their own
content; whereas synthetic judgements become evident when one has acquired some
particular evidence for them.

A logical theory has, then, both analytic and synthetic judgements; the
judgement \isprop{P} is analytic, since its evidence follows from the
definition of $P$, whereas the assertion of \istrue{P} entails the knowledge of
some extra information, namely a verification of $P$. When we have extended the
logical theory to a type theory in the manner of the previous sections, the
judgement \ver{M}{P} is also synthetic, since \ver{M}{P} is not self-evident in
general.

But why is it not enough to assert that $M$ verifies $P$ to know \ver{M}{P}? It
suffices to define a $P$ such that one cannot decide in general whether some
term is a verification of it. Let us define the propositional symbol
$\mathsf{P}$, and we intend to know the judgement \isprop{\mathsf{P}}, whose
meaning is to be expanded as follows:
\begin{quote}
  To know \isprop{\mathsf{P}} is to know counts as a canonical verification of $\mathsf{P}$.
\end{quote}

We will say, then, that $\bullet$ is a canonical verification of $\mathsf{P}$
just when Goldbach's conjecture is true. Then it comes immediately that the
judgement \ver{M}{\mathsf{P}} may not be known or refuted on its own basis, nor
even the judgement \ver{\bullet}{\mathsf{P}}, since they depend on an
proposition whose truth is not known:

\begin{itemize}
  \item[] To know \ver{M}{\mathsf{P}} is to know that \reduce{M}{M'} to a
    canonical verification of $P$.
  \item[$\Leftrightarrow$] To know $\ver{M}{\mathsf{P}}$ is to know that
    \reduce{M}{\bullet} such that Goldbach's conjecture is true.
\end{itemize}

\subsection{Proof of a judgement vs.\ verification of a proposition}

Because the judgement \ver{M}{P} is synthetic, we cannot say that it gives rise
to a proof theory for the logic, since the core judgement of a proof theory
$M:A$ must be analytic, in order to avoid the infinite regress of a proof
theory requiring a proof theory requiring a proof theory, and so on.

The notion of verification of a proposition could never be the same as proof
anyway, except in the most trivial circumstances, since a verification is meant
to be an effective operation which realizes the truth of the proposition, and
no constraints whatsoever (termination, totality, etc.) are placed on these
operations except those which come from the meaning of the judgements (see
Dummett).

So a proof theory is necessarily intensional, and its judgements are to be
analytic/decidable. What is it, then, that we have considered so far which
corresponds with a proof $M$ such that $M:P$ in a proof theory? As discussed
above, $M$ is not merely a term such that \ver{M}{P}, since this is not in
general enough information to know whether $M$ is a proof. In fact, $M$ must
comprise all the logical inferences which led to the knowledge that $P$ is
true, and so a meaning explanation for the judgement $M:P$ in a proof theory
immediately suggests itself:
\begin{quote}
  To know $M:P$ is to know that $M$ is evidence of the judgement \istrue{P}.
\end{quote}

And so the term domain of the proof theory is not the same as the one that we
have considered so far; it must consist in terms which represent traces of the
inferences made in the course of knowing the judgements of a logical theory.
There is a sense in which one can consider the types of a proof theory to
interpret the judgements of the logical theory, and this methodology is called
``judgements as types'' (and this implies ``derivations as terms'').

What I am calling a ``proof-theoretic type theory'' is a type theory of the
sort used in the proof assistants Agda, Coq and Idris, whereas the kind of
type theory that I have described in the previous sections, the one based on
meaning explanations, underlies the proof assistant Nuprl.

The proof-theoretic type theories on the one hand are often called
``intensional'' and the meaning-theoretic type theories on the other hand are
usually ``extensional''; these characterizations are certainly true, though I
fear that comparing one of the former with one of the latter is not quite fair,
since there is not any clear analogy to be had. That is to say, the judgement
\ver{M}{P} is a judgement which is added to a logical theory and its meaning is
(briefly) ``$M$ evaluates to a canonical verification of $P$'', whereas $M:P$ cannot
be construed as a judgement added to a logical theory. Instead, it must be
understood as part of a theory which is overlayed atop an existing logical
theory; it is possible to understand the theory which contains the judgement
$M:P$ to be a metatheory, or logical framework, for the theory which contains
the judgement \istrue{P}, which can be construed as the ``object language''.

In short, the judgements \ver{M}{P} and $M:P$ are unrelated to each other in
two respects: firstly, that they have different meanings, and secondly that the
one is at the same level as the judgements of a logical theory, whereas the
latter is a judgement in a theory which is defined over a logical theory.

\subsection{Meaning explanations for proof theoretic type theory}

%% In a computational type theory which is defined by the meaning explanations,
%% the computational content of terms is understood immediately by means of the
%% \reduce{M}{M'} relation; that is, computation is prior to the main judgements
%% because their meaning explanations are defined in terms of evaluation to
%% canonical form.
%%
%% In contrast, the computational content of a proof-theoretic type theory is not
%% understood primitively, but comes through a metamathematical argument (a proof
%% of a property called ``strong normalization''), and is used in practice to
%% implement an algorithm to decide the judgements of the theory. As such, the
%% meaning explanations for this kind of theory do not contain the phrase
%% ``evaluates to a canonical...'', since evaluation can only be understood
%% through a metamathematical argument, which necessarily requires understanding
%% of the judgements of the theory. To avoid this apparent impredicativity, then,
%% the meaning explanation for the judgement $M:A$ doesn't refer to evaluation.

To make this more concrete, let us expound a proof theoretic type theory called
\MLLF, which stands for ``Martin-L\"of's Logical Framework''; in the course of
introducing each type, we will specify which judgement of the underlying
logical theory $\mathcal{L}$ it is meant to interpret. Since we are now
beginning to refer to judgements in multiple theories, where there is
ambiguity, we will use the notation ``$\mathcal{T}$-judgement'' to refer to a
judgement in the theory $\mathcal{T}$, and $\mathcal{T}\vdash\mathcal{J}$ will
be shorthand for ``the $\mathcal{T}$-judgement $\mathcal{J}$ is evident''.

We start with four categorical judgements:\\

\begin{tabular}{c|l}
Judgement & Pronunciation \\ \hline
  \type{\alpha} & $\alpha$ is a type \\
  \type{\alpha=\beta} & $\alpha$ and $\beta$ are equal types \\
  $M:\alpha$ & $M$ is of type $\alpha$ \\
  $M=N:\alpha$ & $M$ and $N$ are equal at type $\alpha$ \\
\end{tabular}

But we have not defined the meaning of the judgements; let us do so below:

\begin{quote}
  To know $\type\alpha$ is to know what counts as an object of type $\alpha$,
  and when two such objects are equal.
\end{quote}

For now, we'll leave the question of what is an ``object'' as abstract; in many
cases, types will represent $\mathcal{L}$-judgements and objects will represent
$\mathcal{L}$-derivations.

\begin{quote}
  To know $\type{\alpha=\beta}$ is to know that any object of type $\alpha$ is
  also an object of type $\beta$, and two equal objects of type $\alpha$ are
  equal as objects of type $\beta$ (necessarily presupposing \type\alpha\ and
  \type\beta).
\end{quote}

\begin{quote}
  To know $M:\alpha$ is to know that $M$ is an object of type $\alpha$
  (necessarily presupposing \type\alpha).
\end{quote}

\begin{quote}
  To know $M=N:\alpha$ is to know that $M$ and $N$ are equal objects of type
  $\alpha$ (necessarily presupposing $M:\alpha$\ and $N:\alpha$).
\end{quote}

Next, we will introduce hypothetical judgement in the logical framework; to
avoid confusion, where \hyp{\mathcal{J}}{\mathcal{J}'} is a hypothetical
$\mathcal{L}$-judgement, we will use \lfhyp{\mathcal{J}}{\mathcal{J}'} for
hypothetical judgements in the logical framework. Then,

\begin{quote}
  To know \lfhyp{\mathcal{J}}{\mathcal{J}_1,\dots,\mathcal{J}_n} is to know $\mathcal{J}$ when one knows $\mathcal{J},\dots,\mathcal{J}_n$.
\end{quote}

At this point, we may begin adding types to the logical framework. In practice,
most types which we will introduce in the logical framework will be defined in
terms of a judgement of the logical theory $\mathcal{L}$ which lies below it.
For instance, hypothetical judgement in $\mathcal{L}$ is represented by a
function type in the logical framework, $(x:\alpha)\beta$, whose typehood is
meant to be evident under the following circumstances
\[
  \infer{
    \type{(x:\alpha)\beta}
  }{
    \type\alpha &
    \lfhyp{\type\beta}{x:\alpha}
  }
\]
Or as a hypothetical judgement,
\lfhyp{\type{(x:\alpha)\beta}}{\type\alpha,\lfhyp{\type\beta}{x:\alpha}}.

Now, to know this judgement is to know that under the circumstances we know
what is an object of type $\alpha$ and when two such objects are equal, and
that if we have such an object $x$, we know what an object of type $\beta$ is,
and when two such objects are equal---then we know what an object of type
$(x:\alpha)\beta$ is. To make this evident, then, we will say that under those
circumstances an object of type $(x:\alpha)\beta$ is an object $[x]M$ such that
one knows \lfhyp{M:\beta}{x:\alpha} and \lfhyp{[y/x]M=[z/x]M}{y=z:\alpha};
furthermore, two such objects are equal just when they yield equal outputs for
equal inputs. (The equality is extensional, but since it is with respect to the
definitional equality, this does not break the decidability of the judgement)

Then, for each atomic $\mathcal{L}$-proposition $P$, we can easily define a
type \prf{P}, as follows. Under the circumstances that
$\mathcal{L}\vdash\isprop{P}$, then $\MLLF\vdash\type{\prf{P}}$, since we will
define an object of type \prf{P} to be an $\mathcal{L}$-derivation of
\istrue{P}; beyond reflexivity, further definitional equalities can be added to
reflect the harmony of introduction and elimination rules.

It is time to revisit what it means to be an ``object'' of a type in the
proof-theoretic type theory; we must note how this will necessarily differ from
what it meant to be a ``verification'' of a proposition in the previous
sections. Namely, a verification of a proposition is either a \emph{canonical
verification} of that proposition (and what sort of thing this might be is
known from the presupposition \isprop{P}), or it is a means of getting such
a canonical verification (i.e. a term which evaluates to a canonical
verification).

On the other hand, what we have called an ``object'' of type $P$ is quite
different, since in addition to the possibility that it is a canonical proof of
the judgement \istrue{P}, it may also be \emph{neutral} (i.e. blocked by a
variable); we will call this ``normal'' rather than ``canonical''. Why does
this happen?

In order to keep the judgement $M:A$ analytic (decidable), its meaning
explanation can no longer be based on the idea of the computation of closed
terms to canonical form; instead, we will consider the computation of open
terms (i.e. terms with free variables) to \emph{normal} form. The desire for
$M:A$ to be analytic follows from our intention that it characterize a
\emph{proof theory}: we must be able to recognize a proof when we see one. But
why are closed-term-based meaning explanations incompatible with this goal?
Consider briefly the following judgement:
\[
  \hyp{M(n) \in P}{n\in\naturals}
\]

To know this judgement is to know that $M(n)$ computes to a canonical
verification of $P$ whenever $n$ is a natural number; when $P$'s use of $n$ is
not trivial, this amounts to testing an infinite domain (all of the natural
numbers), probably by means of mathematical induction. The judgement is then
clearly synthetic: to know it is, briefly, to have come up with an (inductive)
argument that $M(N)$ computes to a canonical verification of $P$ at each
natural number $n$.

On the other hand, the judgement \lfhyp{M(n):P}{n:\naturals} must have a
different meaning, one which admits its evidence or refutation purely on
syntactic/analytic grounds. In essence, it is to know that $M(n)$ is a proof of
$P$ for any \emph{arbitrary} object/expression $n$ such that $n:\naturals$
(i.e., the only thing we know about $n$ is that it is of type $\naturals$; we
do not necessarily know that it is a numeral).

\subsubsection{Finer Judgements for Proof-Theoretic Type Theory}

As soon as we have begun to consider the computation of open terms to normal
form, as opposed to the computation of closed terms to canonical form, a more
fine-grained structure of judgements begins to present itself. We'll replace
the $M:\alpha$ judgement with two new ones:\\

\begin{tabular}{c|l}
  \infers{R}{\alpha} & $R$ \textbf{synthesizes} type $\alpha$\\
  \checks{M}{\alpha} & $M$ \textbf{checks} type $\alpha$\\
\end{tabular}\\

A peculiarity of the notation is that \infers{R}{\alpha} is really a synthetic
judgement involving the expression $R$ only, where the evidence for the
judgement contains $\alpha$. Its meaning explanation is, ``I know of what type $R$
is (and by the way, it is $\alpha$)''.  On the other hand, \checks{M}{\alpha} is
analytic, and it carries the epistemic content of the old $M:\alpha$ judgement; to
know it is to know that $M$ computes to a normal proof of $\alpha$.

Let us amend the meaning explanation for the judgements of type theory; first, typehood,
which will once again be cast in terms of canonical forms (of proofs, not
verifications):
\begin{quote}
  To know \type{\alpha} is to know what counts as a canonical proof of $\alpha$, and when
  two proofs of \type{\alpha} are equal.
\end{quote}

Then the typing judgements are given:
\begin{quote}
  To know \infers{R}{\alpha} is to know that \reduce{R}{R'} such that $R'$ is a non-canonical proof of a known type, namely $\alpha$.
\end{quote}
\begin{quote}
  To know \checks{M}{\alpha} is to know that \reduce{M}{M'} such that $M'$ is a
  normal proof of $\alpha$ (i.e., it is either a canonical proof of $\alpha$ or
  it is a neutral term such that one knows \infers{M}{\alpha}).
\end{quote}

We will restrict the hypothetical judgement to only contain hypotheses of the
form \infers{x}{A} where $x$ is a variable, or \type\alpha\ where $\alpha$ is a
variable, or further hypothetical judgements:
\begin{quote}
  To know
  \lfhyp{\mathcal{J}}{\mathcal{J}_1,\dots,\mathcal{J}_n} is
  to know $\mathcal{J}$ when one knows
  $\mathcal{J}_1,\dots,\mathcal{J}_n$.
\end{quote}

Now, we will show how to make true the judgement \type\alpha\ for a number of
types $\alpha$, by defining them. For example, to define conjunction, first we
introduce the following syntax: \product\alpha\beta, \pair{M}{N}, \fst{R},
\snd{R} subject to the following computation rules:
\begin{gather*}
  \reduce{\fst{\pair{M}{N}}}{M}
  \qquad
  \reduce{\snd{\pair{M}{N}}}{N}\\
  \infer{
    \reduce{\fst{R}}{\fst{R'}}
  }{
    \reduce{R}{R'} &
    \text{$R'$ is neutral}
  }
  \qquad
  \infer{
    \reduce{\snd{R}}{\snd{R'}}
  }{
    \reduce{R}{R'} &
    \text{$R'$ is neutral}
  }
\end{gather*}

The, to make the judgement
\lfhyp{\type{\product\alpha\beta}}{\type\alpha,\type\beta} evident, let's first
expand its meaning explanation.
\begin{quote}
  To know \lfhyp{\type{\product\alpha\beta}}{\type\alpha,\type\beta} is to know
  what counts as a canonical proof of \product\alpha\beta, and when two proofs
  of \product\alpha\beta\ are equal, when one knows that what counts as a
  canonical proof of $\alpha$ and when two proofs of $\alpha$ are equal, and
  one knows what counts as a canonical proof of $\beta$ and when two proofs of
  $\beta$ are equal.
\end{quote}

This is evident, since we will say that a canonical proof of
\product\alpha\beta\ is a pair \pair{M}{N} such that we know \checks{M}{\alpha}
and \checks{N}{\beta}, and that the equality of pairs is structural. This
corresponds to the following inference rules:
\[
  \infer{
    \checks{\pair{M}{N}}{\product\alpha\beta}
  }{
    \checks{M}{\alpha} &
    \checks{N}{\beta}
  }
  \qquad
  \infer{
    \pair{M}{N}=\pair{M'}{N'}:\product\alpha\beta
  }{
    M=M':\alpha &
    N=N':\beta
  }
\]

Based on these definitions and computation rules, the following inference rules are justified:
\begin{gather*}
  \infer{
    \infers{\fst{R}}{\alpha}
  }{
    \infers{R}{\product\alpha\beta}
  }
  \qquad
  \infer{
    \infers{\snd{R}}{\beta}
  }{
    \infers{R}{\product\alpha\beta}
  }\\
  \infer{
    M=\pair{\fst{M}}{\snd{M}}:\product\alpha\beta
  }{
    \checks{M}{\product\alpha\beta}
  }
\end{gather*}

\end{document}
