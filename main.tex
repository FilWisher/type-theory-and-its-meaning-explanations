\documentclass{amsbook}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{dsfont}
\usepackage{multicol}
\usepackage{proof}
\usepackage{setspace}
\usepackage{booktabs}
\usepackage[usenames,dvipsnames,svgnames,table]{xcolor}
\usepackage{stmaryrd}
\usepackage{mathtools}
\usepackage{subfiles}

\newtheorem{thm}{Theorem}[section]
\newtheorem{prop}[thm]{Proposition}
\newtheorem{lem}[thm]{Lemma}
\newtheorem{cor}[thm]{Corollary}
\theoremstyle{definition}
\newtheorem{definition}[thm]{Definition}
\newtheorem{example}[thm]{Example}

\theoremstyle{remark}
\newtheorem{remark}[thm]{Remark}
\numberwithin{equation}{section}

\def\InputModeColorName{MidnightBlue}
\def\OutputModeColorName{Maroon}
\newcommand\InputMode[1]{{\color{\InputModeColorName}{#1}}}
\newcommand\OutputMode[1]{{\color{\OutputModeColorName}{#1}}}

\newcommand\isprop[1]{\ensuremath{\InputMode{#1}\;\mathit{prop}}}
\newcommand\isset[1]{\ensuremath{\InputMode{#1}\;\mathit{type}}}
\newcommand\eisset[2]{\ensuremath{\InputMode{#1}=\InputMode{#2}\;\mathit{type}}}
\newcommand\istrue[1]{\ensuremath{\InputMode{#1}\;\mathit{true}}}
\newcommand\isctx[1]{\ensuremath{\InputMode{#1}\;\mathit{ctx}}}
\newcommand\fresh[2]{\ensuremath{\InputMode{#1}\mathrel{\#}\InputMode{#2}}}
\newcommand\sequent[2]{\ensuremath{\InputMode{#1}\gg#2}}
\newcommand\hyp[2]{\ensuremath{#1\ (#2)}}
\newcommand\ahyp[2]{\ensuremath{#1 & (#2)}}
\newcommand\genj[2]{\ensuremath{\lvert_{\InputMode{#1}}\,#2}}
\newcommand\ver[2]{\ensuremath{\InputMode{#1}\in\InputMode{#2}}}
\newcommand\ever[3]{\ensuremath{\InputMode{#1}=\InputMode{#2}\in\InputMode{#3}}}
\newcommand\ofty[2]{\ensuremath{\InputMode{#1}:\InputMode{#2}}}
\newcommand\eofty[3]{\ensuremath{\InputMode{#1}=\InputMode{#2}:\InputMode{#3}}}
\newcommand\reduce[2]{\ensuremath{\InputMode{#1}\Rightarrow\OutputMode{#2}}}
\newcommand\areduce[2]{\ensuremath{\InputMode{#1}&\Rightarrow\OutputMode{#2}}}
\newcommand\naturals{\ensuremath{\mathbb{N}}}
\newcommand\suc[1]{\ensuremath{\mathsf{S}(#1)}}
\newcommand\natrec[3]{\ensuremath{\mathsf{rec}_\naturals(#1;#2;#3)}}
\newcommand\lfsequent[2]{\ensuremath{\InputMode{#1}\vdash#2}}
\newcommand\prf[1]{\ensuremath{\mathsf{Prf}(#1)}}
\newcommand\MLLF{\textbf{MLLF}}
\newcommand\infers[2]{\ensuremath{\InputMode{#1}\Rightarrow{\OutputMode{#2}}}}
\newcommand\checks[2]{\ensuremath{\InputMode{#1}\Leftarrow\InputMode{#2}}}

\newcommand\type[1]{\ensuremath{\InputMode{#1}:\mathit{type}}}
\newcommand\etype[2]{\ensuremath{\InputMode{#1}=\InputMode{#2}:\mathit{type}}}
\newcommand\cantype[1]{\ensuremath{\InputMode{#1}\mathrel{\epsilon}\mathit{type}}}
\newcommand\product[2]{\ensuremath{#1\&#2}}
\newcommand\pair[2]{\ensuremath{\langle #1,#2\rangle}}
\newcommand\fst[1]{\ensuremath{\mathsf{fst}(#1)}}
\newcommand\snd[1]{\ensuremath{\mathsf{snd}(#1)}}
\newcommand\abort[2]{\ensuremath{\mathsf{abort}(#1;#2)}}

\newcommand\tyunit{\ensuremath{\mathsf{unit}}}
\newcommand\tyvoid{\ensuremath{\mathsf{void}}}
\newcommand\typrod[3]{\ensuremath{\mathsf{\Pi}(#1;#2.#3)}}
\newcommand\lam[2]{\ensuremath{\mathsf{\lambda}(#1.#2)}}
\newcommand\ap[2]{\ensuremath{\mathsf{ap}(#1;#2)}}

\newcommand\val{\ensuremath{\mathbf{val}}}
\newcommand\utm{\ensuremath{\mathbf{use}}}
\newcommand\rtm{\ensuremath{\mathbf{neu}}}
\newcommand\mtm{\ensuremath{\mathbf{exp}}}

\newcommand\lfctx[1]{\ensuremath{\InputMode{#1}:\mathit{ctx}}}
\newcommand\ufst{\ensuremath{\mathsf{fst}}}
\newcommand\usnd{\ensuremath{\mathsf{snd}}}
\newcommand\uap[1]{\ensuremath{\mathsf{ap}(#1)}}
\newcommand\uabort[1]{\ensuremath{\mathsf{abort}(#1)}}
\newcommand\elim[2]{\ensuremath{#1@#2}}
\newcommand\valof[2]{\ensuremath{\InputMode{#1}\mathrel{\epsilon}\InputMode{#2}}}
\newcommand\useof[4]{\ensuremath{\InputMode{#1}:\InputMode{#2}>\OutputMode{x}.\,\OutputMode{#4}}}
\newcommand\hsubste[4]{\ensuremath{[\InputMode{#1}/\InputMode{#2}]\InputMode{#3}\leadsto\OutputMode{#4}}}
\newcommand\hsubstr[4]{\ensuremath{[\InputMode{#1}/\InputMode{#2}]\InputMode{#3}\leadsto\OutputMode{#4}}}
\newcommand\hsubstrm[4]{\ensuremath{[\InputMode{#1}/\InputMode{#2}]\InputMode{#3}\leadsto\OutputMode{#4}}}
\newcommand\hsubstm[4]{\ensuremath{[\InputMode{#1}/\InputMode{#2}]\InputMode{#3}\leadsto\OutputMode{#4}}}
\newcommand\hsubstu[4]{\ensuremath{[\InputMode{#1}/\InputMode{#2}]\InputMode{#3}\leadsto\OutputMode{#4}}}

\newcommand\hasvar[3]{\ensuremath{\InputMode{#1}(\InputMode{#2})\leadsto\OutputMode{#3}}}
\newcommand\eapply[3]{\ensuremath{\InputMode{#1}\diamond\InputMode{#2}\leadsto\OutputMode{#3}}}
\newcommand\match[2]{\ensuremath{\InputMode{#1}\equiv\OutputMode{#2}}}
\newcommand\ival[1]{\ensuremath{\uparrow#1}}
\newcommand\ineu[1]{\ensuremath{\mathsf{neu}(#1)}}

\begin{document}
\title{Type theory and its meaning explanations}
\author{Jonathan Sterling}

\thanks{Thanks to Bob Harper, Peter Dybjer, Bengt Nordstr\"om, Carlo Angiuli
and Darin Morrison for invaluable conversations which helped sharpen my view of
the meaning explanations for computational and intensional type theories. All
mistakes are mine.}

% \address{AlephCloud Systems}
% \email{jon@jonmsterling.com}

\maketitle

\begin{abstract}
  At the heart of intuitionistic type theory lies an intuitive semantics called
  the ``meaning explanations''; crucially, when meaning explanations are taken as
  definitive for type theory, the core notion is no longer ``proof'' but
  ``verification''. We'll explore how type theories of this sort arise naturally
  as enrichments of logical theories with further judgements, and contrast this
  with modern proof-theoretic type theories which interpret the judgements and
  proofs of logics, not their propositions and verifications.
\end{abstract}

\onehalfspacing

\tableofcontents

\subfile{logicaltheory}
\subfile{ctt}
\subfile{prooftheory}


\bibliographystyle{plain}
\nocite{*}
\bibliography{refs}

\end{document}
