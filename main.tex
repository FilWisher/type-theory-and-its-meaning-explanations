\documentclass{amsart}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{dsfont}
\usepackage{multicol}
\usepackage{proof}
\usepackage{setspace}
\usepackage{stmaryrd}

\newtheorem{thm}{Theorem}[section]
\newtheorem{prop}[thm]{Proposition}
\newtheorem{lem}[thm]{Lemma}
\newtheorem{cor}[thm]{Corollary}
\theoremstyle{definition}
\newtheorem{definition}[thm]{Definition}
\newtheorem{example}[thm]{Example}

\theoremstyle{remark}
\newtheorem{remark}[thm]{Remark}
\numberwithin{equation}{section}

\newcommand\isprop[1]{\ensuremath{#1\;\mathit{prop}}}
\newcommand\istrue[1]{\ensuremath{#1\;\mathit{true}}}
\newcommand\hyp[2]{\ensuremath{#1\ (#2)}}
\newcommand\ver[2]{\ensuremath{#1\in#2}}
\newcommand\reduce[2]{\ensuremath{#1\Rightarrow#2}}
\newcommand\naturals{\ensuremath{\mathbb{N}}}
\newcommand\suc[1]{\ensuremath{\mathsf{S}(#1)}}
\newcommand\natrec[3]{\ensuremath{\mathsf{rec}_\naturals(#1;#2;#3)}}
\newcommand\lfhyp[2]{\ensuremath{#1\ [#2]}}
\newcommand\MLLF{\textbf{MLLF}}

\newcommand\type[1]{\ensuremath{#1:\mathit{type}}}

\begin{document}
\title{Type theory and its meaning explanations}
\author{Jonathan Sterling}
% \address{AlephCloud Systems}
% \email{jon@jonmsterling.com}

\maketitle

\onehalfspacing

To start, we will consider the notion of a \emph{logical theory}; in my mind,
it starts with a species (or set) of judgements that can be proposed, asserted,
and (if they are evident) known.

\section{Judgements of a Logical Theory}

The basic forms of judgement for a logical theory will be \framebox{\isprop{P}} and
\framebox{\istrue{P}}; and what is $P$? It is a member of the species of terms,
which are made meaningful in the course of making the judgement
$\isprop{P}$ evident for a proposition $P$.

To each judgement is assigned a \emph{meaning explanation}, which explicates
the knowledge-theoretic content of the judgement. For a judgement
$\mathcal{J}$, a meaning explanation should be in the form:
\begin{quote}
  To know $\mathcal{J}$ is to know...
\end{quote}

The meaning of the judgement \isprop{P} is, then, as follows:
\begin{quote}
  To know \isprop{P} is to know that $P$ is a proposition, which is to know
  what counts as a direct verification of $P$.
\end{quote}

So if a symbol $P$ is taken to denote a proposition, we must know \emph{what
sort of thing} is to be taken as a direct verification of $P$, and this is by
definition. A ``direct verification'' is understood in constrast with an
``indirect verification'', which is to be thought of as a means or plan for
verifying the proposition. Now, the judgement \istrue{P} is only meaningful in
case we know \isprop{P} (this is called a presupposition). Then the meaning of
\istrue{P} is as follows:
\begin{quote}
  To know \istrue{P} is to have a verification of $P$.
\end{quote}

From the (implicit) presupposition \isprop{P}, we already know what counts as a
verification, so the meaning explanation is well-defined. Note that it is the
same to have a means or plan for verifying $P$ as to have a (direct)
verification; this follows from the fact that one may put into action a plan
for verifying $P$ and get out such a verification, and likewise, it is possible
to propound a plan of verification by appealing to an existing verification.

The judgements we have described so far are ``categorical'' in the sense that
they are made without assumption. We will need to define a further form of
judgement, which is called ``hypothetical'', and this is the judgement under
hypothesis \framebox{\hyp{\mathcal{J}}{\mathcal{J}_1\dots\mathcal{J}_n}}. And
its meaning explanation is as follows:

\begin{quote}
  To know the judgement \hyp{\mathcal{J}}{\mathcal{J}_1\dots\mathcal{J}_n} is to know the
  categorical judgement $\mathcal{J}$ when you know the judgements
  $\mathcal{J}_1\dots\mathcal{J}_n$.
\end{quote}


\section{Propositions}
Now that we have propounded and explained the minimal system of judgements for
a logical theory, let us populate it with propositions. First, we have falsity
$\bot$, and we wish to make \isprop{\bot} evident; to do this, we simply state
what counts as a direct verification of $\bot$, which is that there can be no
direct verification of $\bot$.

The next basic proposition is trivially true $\top$, and to make \isprop{\top}
evident, we state that a direct verification of $\top$ is trivial. The meaning
of $\top$ thus validates the judgement \istrue{\top}.

Next, let us define conjunction; in doing so, we will make evident the
hypothetical judgement \hyp{\isprop{P\land Q}}{\isprop{P},\isprop{Q}};
equivalently, we can display this as a rule of inference:
\[
  \infer{
    \isprop{P\land Q}
  }{
    \isprop{P} &
    \isprop{Q}
  }
\]

A direct verification of $P\land Q$ consists in a verification of $P$
and a verification of $Q$; this validates the assertion of the judgement
\hyp{\istrue{P\land Q}}{\istrue{P},\istrue{Q}}. Because it is a valid
inference, we can write it as an inference rule:
\[
  \infer{
    \istrue{P\land Q}
  }{
    \istrue{P} &
    \istrue{Q}
  }
\]

A direct verification of $P\lor Q$ may be got either from a verification
of $P$ or one of $Q$. From this definition we know \hyp{\isprop{P\lor
Q}}{\isprop{P},\isprop{Q}}, or
\[
  \infer{
    \isprop{P\lor Q}
  }{
    \isprop{P} &
    \isprop{Q}
  }
\]
The verification conditions of disjunction give
rise to two evident judgements \hyp{\istrue{P\lor Q}}{\istrue{P}} and
\hyp{\istrue{P\lor Q}}{\istrue{Q}}, which we can write as inference rules:
\begin{gather*}
  \infer{
    \istrue{P\lor Q}
  }{
    \istrue{P}
  }
  \qquad
  \infer{
    \istrue{P\lor Q}
  }{
    \istrue{Q}
  }
\end{gather*}

Finally, we must define the circumstances under which $P\supset Q$ is a
proposition (i.e.\ when \isprop{P\supset Q} is evident). And we intend this to
be under the circumstances that $P$ is a proposition, and also that $Q$ is a
proposition assuming that $P$ is true. In other words, \hyp{\isprop{P\supset
Q}}{\isprop{P}, \hyp{\isprop{Q}}{\istrue{P}}}, or
\[
  \infer{
    \isprop{P\supset Q}
  }{
    \isprop{P} &
    \hyp{\isprop{Q}}{\istrue{P}}
  }
\]

Now, to validate this judgement will be a bit more complicated than the
previous ones. But by unfolding the meaning explanations for hypothetical
judgement, proposition-hood and truth of a proposition, we arrive at the
following explanation:
\begin{quote}
  To know \hyp{\isprop{P\supset Q}}{\isprop{P},\hyp{\isprop{Q}}{\istrue{P}}} is
  to know what counts as a direct verification of $P\supset Q$ when one knows what
  counts as a direct verification of $P$, and, when one has such a verification, what
  counts as a direct verification of $Q$.
\end{quote}

(Note that unless \istrue{P}, it need not be evident that \isprop{Q}.) Now, if
this judgement is going to be made evident, then we must indeed come up with
what should count as a direct verification of $P\supset Q$ under the
assumptions described above.

And so to have a direct verification of $P\supset Q$ is to have a
verification of $Q$ assuming that one has one of $P$; this is the meaning of
implication, and it validates the judgement \hyp{\istrue{P\supset
Q}}{\hyp{\istrue{Q}}{\istrue{P}}} (elliding the hypothesis for
propositionhood), and may be written as an inference rule as follows:
\[
  \infer{
    \istrue{P\supset Q}
  }{
    \hyp{\istrue{Q}}{\istrue{P}}
  }
\]

\section{Judgements for Verifications}

So far, we have given judgements which circumscribe what it means to be a
proposition, and thence for each proposition, we have by definition a notion of
what should count as a verification of that proposition. And by definition, to
assert the judgement \istrue{P} is to assert that one has a verification of $P$,
but we have not considered any judgements which actually describe such
verifications.

It is a hallmark of Martin-L\"of's program to resolve the contradiction between
syntax and semantics not by choosing symbols over meanings or meanings over
symbols, but by endowing symbols with meaning in the course of making evident
the true judgements. As such $P$ is a symbol, but when we assert \isprop{P} we
are saying that we know what proposition $P$ denotes.

A similar thing can be done with verifications themselves, by placing them in
the syntactic domain together with the propositional symbols. And then, we can
consider a judgement such as ``$M$ is a verification of $P$'', and in knowing
that judgement, we know what verification $M$ is meant to denote. In practice,
this judgement has been written in several ways:\\\medskip
\begin{tabular}{c|l}
  $M\in P$ & $M$ is an element of $P$\\
  $M\Vdash P$ & $M$ realizes $P$\\
  $P\ \llcorner\mathsf{ext}\; M\lrcorner$ & $P$ is witnessed by $M$
\end{tabular}

But they all mean the same thing, and so we will tentatively give the following
meaning explanation to this new judgement:
\begin{quote}
  * To know $\ver{M}{P}$ is to know that $M$ is a verification of $P$.
\end{quote}

But now that we have started to assign expressions to verifications, we must be
more careful about differentiating \emph{direct verifications} (which we will
call ``canonical'') from \emph{indirect verifications} (which we will call
``non-canonical''). So the domain of expressions must itself be accorded with a
notion of reduction to canonical form, and this corresponds with putting into
action a plan of verification in order to get an actual verification.
\begin{quote}
  To know \reduce{M}{M'} is to know that $M$ is an expression which reduces to
  a canonical form $M'$.
\end{quote}

Now, we can rewrite the previous meaning explanation as follows:
\begin{quote}
  To know \ver{M}{P} is to know an $M'$ such that \reduce{M}{M'} and $M'$ is a
  canonical (direct) verification of $P$.
\end{quote}

The meaning explanation for \isprop{P} must be accordingly modified to take
into account the computational behavior of the expression domain:
\begin{quote}
  To know \isprop{P} is to know a $P'$ such that \reduce{P}{P'} and $P'$ is a
  canonical proposition, which is to say, that one knows what counts as a
  canonical verification for $P'$.
\end{quote}

As an example, then, we will update the evidence of the assertion
\hyp{\isprop{P\supset Q}}{\isprop{P},\hyp{\isprop{Q}}{\isprop{P}}}. The meaning
of this, expanded into spoken language, is as follows:
\begin{quote}
  To know \hyp{\isprop{P\supset Q}}{\isprop{P},\hyp{\isprop{Q}}{\isprop{P}}} is
  to know what counts as a canonical verification of $P\subset Q$ under
  the circumstances that \reduce{P}{P'}, such one knows what counts as a
  canonical verification $P'$, and, if one has such a verification,
  \reduce{Q}{Q'} such that one knows what counts as a canonical verification of
  $Q'$.
\end{quote}

And this is evident, since we will say that a canonical verification of
$P\subset Q$ is an expression $\lambda x. E$ such that we know
\hyp{\ver{E}{Q}}{\ver{x}{P}}. This validates the assertion \hyp{\ver{\lambda
x.E}{P\supset Q}}{\hyp{\ver{E}{Q}}{\ver{x}{P}}}, written as an inference rule:
\[
  \infer{
    \ver{\lambda x.E}{P\supset Q}
  }{
    \hyp{\ver{E}{Q}}{\ver{x}{P}}
  }
\]

By the addition of this judgement, we have graduated from a logical theory to a
type theory, in the sense of \emph{Constructive Mathematics and Computer
Programming} (Martin-L\"of, 1979). In fact, we may dispense with the original
\istrue{P} form of judgement by \emph{defining} it in terms of the new
\ver{M}{P} judgement as follows:
\[
  \infer{
    \istrue{P}
  }{
    \ver{M}{P}
  }
\]

Further forms of judgement, such as assertions of equality between propositions
and verifications, may be added, as Martin-L\"of does. However, this is not
strictly necessary as they too may be defined in terms of the $\ver{M}{P}$
judgement in the presence of an \emph{equality} proposition; this is what is
done in Constable et al's Computational Type Theory, which has only one
primitive form of judgement.

[TODO] Give the syntax of full type theory and expand the meaning explanations
to account for new propositions and verifications


\section{Proof-Theoretic Type Theory}

\subsection{Analytic and Synthetic Judgement}

The judgements of the theory we have developed so far are uniformly
\emph{synthetic}. Now, a synthetic judgement is one for which the experience of
\emph{coming to know it} necessarily results in the synthesis of some new
information; on the other hand, to know an \emph{analytic} judgement is to know
it purely on the basis of the information contained inside it. So analytic
judgements are decidable, since if they may become evident, it will be purely
on the basis of their own conent; whereas synthetic judgements become evident
when one has acquired some particular evidence for them.

The judgements of a logical theory are then synthetic, since to know \isprop{P}
is to know some extra information (which is, what counts as a verification of
$P$); and to know \istrue{P} is also to know some extra information, namely to
know a verification of $P$. It is not surprising, then, that when we have
extended the logical theory to a type theory in the manner of the previous
sections, that the judgement \ver{M}{P} is also synthetic, since \ver{M}{P} is
not self-evident in general.

But why is it not enough to assert that $M$ verifies $P$ to know \ver{M}{P}? It
suffices to define a $P$ such that one cannot decide in general whether some
term is a verification of it. Let us define the propositional symbol
$\mathsf{P}$, and we intend to know the judgement \isprop{\mathsf{P}}, whose
meaning is to be expanded as follows:
\begin{quote}
  To know \isprop{\mathsf{P}} is to know counts as a canonical verification of $\mathsf{P}$.
\end{quote}

We will say, then, that $\bullet$ is a canonical verification of $\mathsf{P}$
just when Goldbach's conjecture is true. Then it comes immediately that the
judgement \ver{M}{\mathsf{P}} may not be known or refuted on its own basis, nor
even the judgement \ver{\bullet}{\mathsf{P}}, since they depend on an
proposition whose truth is not known:

\begin{itemize}
  \item[] To know \ver{M}{\mathsf{P}} is to know that \reduce{M}{M'} to a
    canonical verification of $P$.
  \item[$\Leftrightarrow$] To know $\ver{M}{\mathsf{P}}$ is to know that
    \reduce{M}{\bullet} such that Goldbach's conjecture is true.
\end{itemize}

\subsection{Proof of a judgement vs.\ verification of a proposition}

Because the judgement \ver{M}{P} is synthetic, we cannot say that it gives rise
to a proof theory for the logic, since the core judgement of a proof theory
$M:A$ must be analytic, in order to avoid the infinite regress of a proof
theory requiring a proof theory requiring a proof theory, and so on.

The notion of verification of a proposition could never be the same as proof
anyway, except in the most trivial circumstances, since a verification is meant
to be an effective operation which realizes the truth of the proposition, and
no constraints whatsoever (termination, totality, etc.) are placed on these
operations except those which come from the meaning of the judgements (see
Dummett).

So a proof theory is necessarily intensional, and its judgements are to be
analytic/decidable. What is it, then, that we have considered so far which
corresponds with a proof $M$ such that $M:P$ in a proof theory? As discussed
above, $M$ is not merely a term such that \ver{M}{P}, since this is not in
general enough information to know whether $M$ is a proof. In fact, $M$ must
comprise all the logical inferences which led to the knowledge that $P$ is
true, and so a meaning explanation for the judgement $M:P$ in a proof theory
immediately suggests itself:
\begin{quote}
  To know $M:P$ is to know that $M$ is evidence of the judgement \istrue{P}.
\end{quote}

And so the term domain of the proof theory is not the same as the one that we
have considered so far; it must consist in terms which represent traces of the
inferences made in the course of knowing the judgements of a logical theory.
There is a sense in which one can consider the types of a proof theory to
interpret the judgements of the logical theory, and this methodology is called
``judgements as types'' (and this implies ``derivations as terms'').

What I am calling a ``proof-theoretic type theory'' is a type theory of the
sort used in the the proof assistants Agda, Coq and Idris, whereas the kind of
type theory that I have described in the previous sections, the one based on
meaning explanations, underlies the proof assistant Nuprl.

The proof-theoretic type theories on the one hand are often called
``intensional'' and the meaning-theoretic type theories on the other hand are
usually ``extensional''; these characterizations are certainly true, though I
fear that comparing one of the former with one of the latter is not quite fair,
since there is not any clear analogy to be had. That is to say, the judgement
\ver{M}{P} is a judgement which is added to a logical theory and its meaning is
(briefly) ``$M$ evaluates to a canonical proof of $P$'', whereas $M:P$ cannot
be construed as a judgement added to a logical theory. Instead, it must be
understood as part of a theory which is overlayed atop an existing logical
theory; it is possible to understand the theory which contains the judgement
$M:P$ to be a metatheory, or logical framework, for the theory which contains
the judgement \istrue{P}, which can be construed as the ``object language''.

In short, the judgements \ver{M}{P} and $M:P$ are unrelated to each other in
two respects: firstly, that they have different meanings, and secondly that the
one is at the same level as the judgements of a logical theory, whereas the the
latter is a judgement in a theory which is defined over a logical theory.

\subsection{Meaning explanations for proof theoretic type theory}

%% In a computational type theory which is defined by the meaning explanations,
%% the computational content of terms is understood immediately by means of the
%% \reduce{M}{M'} relation; that is, computation is prior to the main judgements
%% because their meaning explanations are defined in terms of evaluation to
%% canonical form.
%%
%% In contrast, the computational content of a proof-theoretic type theory is not
%% understood primitively, but comes through a metamathematical argument (a proof
%% of a property called ``strong normalization''), and is used in practice to
%% implement an algorithm to decide the judgements of the theory. As such, the
%% meaning explanations for this kind of theory do not contain the phrase
%% ``evaluates to a canonical...'', since evaluation can only be understood
%% through a metamathematical argument, which necessarily requires understanding
%% of the judgements of the theory. To avoid this apparent impredicativity, then,
%% the meaning explanation for the judgement $M:A$ doesn't refer to evaluation.

To make this more concrete, let us expound a proof theoretic type theory called
\MLLF, which stands for ``Martin-L\"of's Logical Framework''; in the course of
introducing each type, we will specify which judgement of the underlying
logical theory $\mathcal{L}$ it is meant to interpret. Since we are now
beginning to refer to judgements in multiple theories, where there is
ambiguity, we will use the notation ``$\mathcal{T}$-judgement'' to refer to a
judgement in the theory $\mathcal{T}$, and $\mathcal{T}\vdash\mathcal{J}$ will
be shorthand for ``the $\mathcal{T}$-judgement $\mathcal{J}$ is evident''.

We start with four categorical judgements:\\

\begin{tabular}{c|l}
Judgement & Pronunciation \\ \hline
  \type{\alpha} & $\alpha$ is a type \\
  \type{\alpha=\beta} & $\alpha$ and $\beta$ are equal types \\
  $M:\alpha$ & $M$ is of type $\alpha$ \\
  $M=N:\alpha$ & $M$ and $N$ are equal at type $\alpha$ \\
\end{tabular}

But we have not defined the meaning of the judgements; let us do so below:

\begin{quote}
  To know $\type\alpha$ is to know what counts as an object of type $\alpha$,
  and when two such objects are equal.
\end{quote}

We leave the question of what is an ``object'' as abstract, allowing that to be
defined on a type-by-type basis; in many cases, types will represent
$\mathcal{L}$-judgements and objects will represent $\mathcal{L}$-derivations.

\begin{quote}
  To know $\type{\alpha=\beta}$ is to know that any object of type $\alpha$ is
  also an object of type $\beta$, and two equal objects of type $\alpha$ are
  equal as objects of type $\beta$ (necessarily presupposing \type\alpha and
  \type\beta).
\end{quote}

\begin{quote}
  To know $M:\alpha$ is to know that $M$ is an object of type $\alpha$
  (necessarily presupposing \type\alpha).
\end{quote}

\begin{quote}
  To know $M=N:\alpha$ is to know that $M$ and $N$ are equal objects of type
  $\alpha$ (necessarily presupposing $M:\alpha$ and $N:\alpha$).
\end{quote}

Next, we will introduce hypothetical judgement in the logical framework; to
avoid confusion, where \hyp{\mathcal{J}}{\mathcal{J}'} is a hypothetical
$\mathcal{L}$-judgement, we will use \lfhyp{\mathcal{J}}{\mathcal{J}'} for
hypothetical judgements in the logical framework. Then,

\begin{quote}
  To know \lfhyp{\mathcal{J}}{\mathcal{J}_1\dots\mathcal{J}_n} is to know $\mathcal{J}$ when one knows $\mathcal{J}...\mathcal{J}_n$.
\end{quote}

At this point, we may begin adding types to the logical framework. In practice,
most types which we will introduce in the logical framework will be defined in
terms of a judgement of the logical theory $\mathcal{L}$ which lies below it.
For instance, hypothetical judgement in $\mathcal{L}$ is represented by a
function type in the logical framework, $(x:\alpha)\beta$, whose typehood is
meant to be evident under the following circumstances
\[
  \infer{
    \type{(x:\alpha)\beta}
  }{
    \type\alpha &
    \lfhyp{\type\beta}{x:\alpha}
  }
\]
Or as a hypothetical judgement,
\lfhyp{\type{(x:\alpha)\beta}}{\type\alpha,\lfhyp{\type\beta}{x:\alpha}}.

Now, to know this judgement is to know that under the circumstances we know
what is an object of type $\alpha$ and when two such objects are equal, and
that if we have such an object $x$, we know what an object of type $\beta$ is,
and when two such objects are equal---then we know what an object of type
$(x:\alpha)\beta$ is. To make this evident, then, we will say that under those
circumstances an object of type $(x:\alpha)\beta$ is an object $[x]M$ such that
one knows \lfhyp{M:\beta}{x:\alpha} and \lfhyp{[y/x]M=[z/x]M}{y=z:\alpha};
furthermore, two such objects are equal just when they yield equal outputs for
equal inputs. (The equality is extensional, but since it is with respect to the
definitional equality, this does not break the decidability of the judgement)

Then, for each atomic $\mathcal{L}$-proposition $P$, we can easily define a
type $\llcorner P\lrcorner$, as follows. Under the circumstances that
$\mathcal{L}\vdash\isprop{P}$, then $\MLLF\vdash\type{\llcorner P\lrcorner}$,
since we will define an object of type $\llcorner P\lrcorner$ to be an
$\mathcal{L}$-derivation of \istrue{P}; beyond reflexivity, further
definitional equalities can be added to reflect the harmony of introduction and
elimination rules.

\end{document}
