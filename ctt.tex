\documentclass[main.tex]{subfiles}

\begin{document}
\onehalfspacing

\chapter{Computational Type Theories}

As alluded to at the end of the previous chapter, we may add a judgement
\ver{M}{A} which deals directly with the objects $M$ which verify the
propositions (or types) $P$. We will develop a full theory of dependent types in
the sense of Martin-L\"of 1979.

\section{The judgments of a computational type theory}

Because we will need to consider the introduction of types which do not have a
trivial (intensional) equality relation, we must first amend the meaning
explanations for some of our judgements, and add a few new forms of judgement.
First, we will refer to \emph{types} rather than \emph{propositions} in order
to emphasize the generality of the theory; in some places, the word \emph{set}
is used instead.

The meaning of hypothetical and general judgement are the same as in the
previous chapter, and so we will not reproduce them here.

The first form of judgement is \framebox{\isset{A}}, and its meaning explanation
is as follows:

\begin{quote}
  To know \isset{A} is to know what counts as a canonical verification of $A$
  and when two such verifications are equal.
\end{quote}

The next form of judgement is \framebox{\ver{M}{A}}, which remains the same as before:

\begin{quote}
  To know \ver{M}{A} (presupposing \isset{A}) is to know an $M'$ such that
  \reduce{M}{M'} and $M'$ is a canonical verification of $A$.
\end{quote}

We'll need to add new judgements for equality (equality of types, and equality
of verifications). For equality of types \framebox{\isset{A=B}}, there are a
number of possible meaning explanations, but we'll use the one that
Martin-L\"of used starting in 1979\footnote{This meaning explanation was
abandoned in Constable's Computational Type Theory for practical reasons.}:

\begin{quote}
  To know \isset{A=B} (presupposing \isset{A} and \isset{B}) is to know
\genj{M}{\hyp{\ver{M}{B}}{\ver{M}{A}}} and
\genj{M}{\hyp{\ver{M}{A}}{\ver{M}{B}}}, and moreover
\genj{M,N}{\hyp{\ver{M=N}{B}}{\ver{M=N}{A}}} and
\genj{M,N}{\hyp{\ver{M=N}{A}}{\ver{M=N}{A}}}.
\end{quote}

In other words, two types are equal when they have the same canonical
verifications, and moreover, the same equality relation over their canonical
verifications.

Now, because we are allowing the definition of types with arbitrary equivalence
relations, we cannot use plain hypothetico-general judgement in the course of
defining our types. For instance, if we were going to try and define the
function type $A\supset B$ in the same way as we did in the previous chapter,
we would permit ``functions'' which are not in fact functional, i.e.\ they do
not take equal inputs to equal outputs. As such, we will need to bake
functionality (also called extensionality) into the definition of functions,
and since we will need this in many other places, we elect to simplify our
definitions by baking it into a single judgement which is meant to be used
instead of hypothetico-general judgement.

The judgement which expresses simultaneously generality, hypothesis and
functionality has been written in multiple ways. Martin-L\"of has always
written it as \hyp{\mathcal{J}}{\Gamma}, but this is a confusing notation
because it appears as though it is merely a hypothetical judgement (but it is
much more, as will be seen). Very frequently, it is written with a turnstile,
$\Gamma\vdash\mathcal{J}$, and in the early literature surrounding Constable's
Computational Type Theory and Nuprl, it was written
\framebox{\sequent{\Gamma}{\mathcal{J}}}; we choose this last option to avoid
confusion with a similar judgement form which appears in proof-theoretic,
intensional type theories; we'll call the judgement form a ``sequent''.

This judgement must be defined simultaneously with two other judgements,
\framebox{\isctx{\Gamma}} (``$\Gamma$ is a context'') and
\framebox{\fresh{x}{\Gamma}} (``$x$ is fresh in $\Gamma$).

\begin{quote}
  To know \isctx\Gamma\ is to know that \reduce{\Gamma}{\cdot}, or it is to know
  a variable $x$ and an expression $A$ such that \reduce{\Gamma}{\Gamma', \ver{x}{A}}
  and \sequent{\Gamma'}{\isset{A}}, and \fresh{x}{\Gamma}.
\end{quote}

\begin{quote}
  To know \fresh{x}{\Gamma}\ is to know that \reduce{\Gamma}{\cdot}, or it is to know
  a variable $y$ (which is not $x$) and an expression $A$ such that \reduce{\Gamma}{\Gamma', \ver{x}{A}}
  and \fresh{x}{\Gamma'}.
\end{quote}

In other words contexts are inductively generated by the following grammar:
\begin{gather*}
  \infer{\isctx\cdot}{}
  \qquad
  \infer{
    \isctx{\Gamma,\ver{x}{A}}
  }{
    \isctx\Gamma &
    \sequent{\Gamma}{\isset{A}} &
    \fresh{x}{\Gamma}
  }\\
  \infer{\fresh{x}{\cdot}}{}
  \qquad
  \infer{
    \fresh{x}{\Gamma,\ver{y}{A}}
  }{
    \fresh{x}{\Gamma}
  }
\end{gather*}

We will say that \sequent{\Gamma}{\mathcal{J}} is only a judgement under the
presuppositions that \isctx\Gamma\ and that $\mathcal{J}$ is a categorical
judgement of the form \isset{A}\ or \ver{M}{A}. Its meaning explanation must be
given separately for each kind of conclusion.

Preliminarily, for any context $\Gamma$, let $\vec\Gamma_0$ represent the
sequence of its variables and let $\vec\Gamma_1$ represent the sequence of
their types. Then, when we use a sequence in place of an expression in a
judgement, it is meant as a shorthand for an iterated judgement over the entire
sequence.

Now we may begin giving the meaning explanations for
\sequent{\Gamma}{\mathcal{J}}, starting with typehood with respect to a context:

\begin{quote}
  To know \sequent{\Gamma}{\isset{A}} is to know
  \genj{\vec{M}}{\hyp{\isset{[\vec{M}/\vec\Gamma_0]A}}{\ver{\vec{M}}{\vec\Gamma_1}}},
  and moreover, to know
  \[\genj{\vec{M},\vec{N}}{\hyp{\isset{[\vec{M}/\vec\Gamma_0]A =
  [\vec{N}/\vec\Gamma_0]A}}{\ver{\vec{M}=\vec{N}}{\vec\Gamma_1}}}\]
\end{quote}

This is quite noisy, so let us expand it:

\begin{quote}
  To know \sequent{\Gamma}{\isset{A}} is to know that for any arbitrary sequence
  of values $\vec{M}$ such that you know $\ver{\vec{M}}{\vec\Gamma_1}$, then
  you know that the substitution of $\vec{M}$ for the variables $\vec\Gamma_0$
  in $A$ is a type (i.e. it is a family of types defined over the types
  $\vec\Gamma_1$); moreover, that this family of types is functional with
  respect to $\Gamma$.
\end{quote}

Then we can explain type equality with respect to a context:

\begin{quote}
  To know \sequent{\Gamma}{\isset{A=B}} is to know
  \[\genj{\vec{M}}{\hyp{\isset{[\vec{M}/\vec\Gamma_0]A=[\vec{M}/\vec\Gamma_0]B}}{\ver{\vec{M}}{\vec\Gamma_1}}}\]
  and moreover, to know
  \[\genj{\vec{M},\vec{N}}{\hyp{\isset{[\vec{M}/\vec\Gamma_0]A =
  [\vec{N}/\vec\Gamma_0]B}}{\ver{\vec{M}=\vec{N}}{\vec\Gamma_1}}}\]
\end{quote}

Next, membership with respect to a context is explained:

\begin{quote}
  To know \sequent{\Gamma}{\ver{L}{A}} is to know
  \[\genj{\vec{M}}{\hyp{\ver{[\vec{M}/\vec\Gamma_0]L}{[\vec{M}/\vec\Gamma_0]A}}{\ver{\vec{M}}{\vec\Gamma_1}}}\]
  and moreover, to know
  \[\genj{\vec{M},\vec{N}}{\hyp{\ver{[\vec{M}/\vec\Gamma_0]L = [\vec{N}/\vec\Gamma_0]L}{[\vec{M}/\vec\Gamma_0]A}}{\ver{\vec{M}=\vec{N}}{\vec\Gamma_1}}}\]
\end{quote}

Finally, member equality with respect to a context has an analogous explanation:

\begin{quote}
  To know \sequent{\Gamma}{\ver{L=L'}{A}} is to know
  \[\genj{\vec{M}}{\hyp{\ver{[\vec{M}/\vec\Gamma_0]L=[\vec{M}/\vec\Gamma_0]L'}{[\vec{M}/\vec\Gamma_0]A}}{\ver{\vec{M}}{\vec\Gamma_1}}}\]
  and moreover, to know
  \[\genj{\vec{M},\vec{N}}{\hyp{\ver{[\vec{M}/\vec\Gamma_0]L = [\vec{N}/\vec\Gamma_0]L'}{[\vec{M}/\vec\Gamma_0]A}}{\ver{\vec{M}=\vec{N}}{\vec\Gamma_1}}}\]
\end{quote}

The simultaneous definition of multiple judgements may seem at first
concerning, but it can be shown to be non-circular by induction on the length
of the context $\Gamma$.

\section{The definitions of types}

We will now define the types of a simple computational type theory without
universes. In the course of doing so, opportunities will arise for further
clarifying the position of the judgements, meaning explanations and proofs on
the one hand, and the propositions, definitions and verifications on the other
hand.

\subsection{The unit type}

First, we introduce two canonical forms with trivial reduction rules:
\begin{equation}
  \reduce\tyunit\tyunit\qquad
  \reduce\bullet\bullet
  \tag{Canonical}
\end{equation}

Next, we intend to make the judgement \isset\tyunit\ evident; and this is done by
defining what counts as a canonical verification of \tyunit and when two such
verifications are equal. To this end, we say that $\bullet$ is a canonical
verification of \tyunit, and that it is equal to itself.  I wish to emphasize
that this is the entire definition of the type: we have introduced syntax, and
we have defined the canonical forms, and there is nothing more to be done.

In traditional treatments of type theory, a type is ``defined'' by writing out
a bunch of inference rules, but in type theory, the definitions that we have
given above are prior to the rules, which are justified in respect of the
definitions and the meaning explanations for the judgements. For instance,
based on the meaning of the various forms of sequent judgement, the following
rules schemes are justified:
\begin{gather*}
  \infer{
    \sequent\Gamma\isset\tyunit
  }{
  }\qquad
  \infer{
    \sequent\Gamma\isset{\tyunit=\tyunit}
  }{
  }\\[6pt]
  \infer{
    \sequent\Gamma\ver\bullet\tyunit
  }{
  }\qquad
  \infer{
    \sequent\Gamma\ver{\bullet=\bullet}{\tyunit}
  }{
  }
\end{gather*}

Each of the assertions above has evidence of a certain kind; since the
justification of these rules with respect to the definitions of the logical
constants and the meaning explanations of the judgements is largely
self-evident, we omit it. It is just important to remember that it is not the
rules which define the types; a type $A$ is defined in the course of causing
the judgement \isset{A} to become evident according to its meaning explanation.
These rules merely codify standard patterns of use, nothing more, and they must
each be justified.

\subsection{The empty type}

The empty type is similarly easy to define. First, we introduce a constant:
\begin{gather*}
  \reduce\tyvoid\tyvoid\tag{Canonical}
\end{gather*}

To make the judgement \isset\tyvoid\ evident, we will say that there are no
canonical verifications of \tyvoid, and be done with it. This definition
validates some further rules schemes:
\begin{gather*}
  \infer{
    \sequent\Gamma\isset\tyvoid
  }{
  }\qquad
  \infer{
    \sequent\Gamma\isset{\tyvoid=\tyvoid}
  }{
  }\\[6pt]
  \infer{
    \mathcal{J}
  }{
    \sequent\Gamma\ver{M}{\tyvoid}
  }
\end{gather*}

The last rule simply says that if we have a verification of \tyvoid, then we
may conclude any judgement whatsoever. Remember that the inference rules are
just notation for an \emph{evident} hypothetical judgement, e.g.\
\hyp{\mathcal{J}}{\sequent\Gamma\ver{M}{\tyvoid}}.

Note that we did not introduce any special constant into the syntax/computation
language to represent the elimination of a verification of \tyvoid\ (in
intensional type theories, this non-canonical form is usually called
$\mathsf{abort}(R)$. This is because, computationally speaking, there is never
any chance that we should ever have use for such a term, since we need only
consider the evaluation of closed terms (which is guaranteed by the meaning
explanations).

\end{document}

