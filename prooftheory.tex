\documentclass[main.tex]{subfiles}

\begin{document}

\onehalfspacing

\chapter{Proof Theories and Logical Frameworks}

\section{Proof-theoretic type theory}

\subsection{Analytic and synthetic Judgement}

A synthetic judgement is one for which the experience of \emph{coming
to know it} necessarily entails some knowledge which is not implicit
in the statement of the judgement; on the other hand, to know an
\emph{analytic} judgement is to know it purely on the basis of the
information contained inside it. So analytic judgements are decidable,
since if they may become evident, it will be purely on the basis of
their own content; whereas synthetic judgements become evident to
someone when they have obtained some particular evidence for them.

A logical theory has, then, both analytic and synthetic judgements;
the judgement $\isprop{P}$ is analytic, since its evidence follows
from the definition of $P$, whereas the assertion of $\istrue{P}$
entails the knowledge of some extra information, namely a verification
of $P$. When we have extended the logical theory to a type theory in
the manner of the previous chapter, the judgement $\ver{M}{P}$ is
also synthetic, since $\ver{M}{P}$ is not self-evident in general.

But why is it not enough to assert that $M$ verifies $P$ to know
whether $\ver{M}{P}$? It suffices to define a $P$ such that one cannot
decide in general whether some term is a verification of it. Let us
define the propositional symbol $\mathsf{P}$, and we intend to know
the judgement $\isprop{\mathsf{P}}$, whose meaning is to be expanded as
follows:
\begin{quote}
  To know $\isprop{\mathsf{P}}$ is to know counts as a canonical verification of $\mathsf{P}$.
\end{quote}

We will say, then, that $\bullet$ is a canonical verification of
$\mathsf{P}$ just when Goldbach's conjecture is true. Then it comes
immediately that the judgement $\ver{M}{\mathsf{P}}$ may not be known
or refuted on its own basis, nor even the judgement
$\ver{\bullet}{\mathsf{P}}$, since they depend on a proposition whose
truth is not known:

\begin{itemize}
  \item[] To know $\ver{M}{\mathsf{P}}$ is to know that $\reduce{M}{M'}$ to a
    canonical verification of $P$.
  \item[$\leadsto$] To know $\ver{M}{\mathsf{P}}$ is to know that
    $\reduce{M}{\bullet}$ such that Goldbach's conjecture is true.
\end{itemize}

\subsection{Proof of a judgement vs.\ verification of a proposition}

Because the judgement $\ver{M}{P}$ is synthetic, we cannot say that it
gives rise to a proof theory for the logic, since the core judgement
of a proof theory $\ofty{M}{A}$ must be analytic, in order to avoid the
infinite regress of a proof theory requiring a proof theory requiring
a proof theory, and so on.

The notion of verification of a proposition could never be the same as proof
anyway, except in the most trivial circumstances, since a verification is meant
to be an effective operation which realizes the truth of a proposition, and no
constraints whatsoever (termination, totality, etc.) are placed on these
operations except those which come from the meaning of the judgements (see
\cite{Dummett:Elements}, \cite{Prawitz12}).

So a proof theory is necessarily intensional, and its judgements are to be
analytic/decidable. What is it, then, that we have considered so far which
corresponds with a proof $M$ such that $\ofty{M}{P}$ in a proof theory? As discussed
above, $M$ is not merely a term such that $\ver{M}{P}$, since this is not in
general enough information to know whether $M$ is a proof. In fact, $M$ must
comprise all the logical inferences which led to the knowledge that $P$ is
true, and so a meaning explanation for the judgement $\ofty{M}{P}$ in a proof theory
immediately suggests itself:
\begin{quote}
  To know $\ofty{M}{P}$ is to know that $M$ is evidence (demonstration, proof,
  derivation) of the judgement $\istrue{P}$.
\end{quote}

And so the term domain of the proof theory is not the same as the one that we
have considered so far; it must consist in terms which represent traces of the
inferences made in the course of knowing the judgements of a logical theory.
There is a sense in which one can consider the types of a proof theory to
interpret the judgements of the logical theory, and this methodology is called
``judgements as types'' (and this implies ``derivations as terms'').

What I am calling a ``proof-theoretic type theory'' is a type theory of the
sort used in the proof assistants Agda, Coq and Idris, whereas the kind of
type theory that I have described in the previous sections, the one based on
meaning explanations, underlies the proof assistant Nuprl.

The proof-theoretic type theories on the one hand are often called
``intensional'' and the meaning-theoretic type theories on the other
hand are usually ``extensional''; these characterizations are
certainly true, though they are not \emph{essential}; moreover, I fear
that comparing one of the former with one of the latter is not quite
fair, since there is not any clear analogy to be had. That is to say,
the judgement $\ver{M}{P}$ is a judgement which is added to a logical
theory and its meaning is (briefly) ``$M$ evaluates to a canonical
verification of $P$'', whereas $\ofty{M}{P}$ cannot be construed as a
judgement added to a logical theory. Instead, it must be understood as
part of a (proof) theory which is overlayed atop an existing logical theory;
it is possible to understand the theory which contains the judgement
$\ofty{M}{P}$ to be a metatheory, or logical framework, for the theory which
contains the judgement $\istrue{P}$, which can be construed as the
``object language''.

In short, the judgements $\ver{M}{P}$ and $\ofty{M}{P}$ are unrelated to each other in
two respects: firstly, that they have different meanings, and secondly that the
one is at the same level as the judgements of a logical theory, whereas the
latter is a judgement in a theory which is defined over a logical theory.

\section{Martin-L\"of's Logical Framework}

To make this more concrete, let us expound a proof theoretic type
theory called \MLLF, which stands for ``Martin-L\"of's Logical
Framework'';\footnote{For a detailed overview of Martin-L\"of's equational logical framework, see \cite{PiMLTT}.} in the course of introducing each type, we will specify
which judgement of the underlying logical theory it is meant to
interpret.

We start with four categorical judgements:\\

\begin{tabular}{c|l}
Judgement Form & Pronunciation \\ \hline
  $\type{\alpha}$ & $\alpha$ is a type \\
  $\etype{\alpha}{\beta}$ & $\alpha$ and $\beta$ are equal types \\
  $\ofty{M}{\alpha}$ & $M$ is of type $\alpha$ \\
  $\eofty{M}{N}{\alpha}$ & $M$ and $N$ are equal at type $\alpha$ \\
\end{tabular}\\

But we have not defined the meaning of the judgements; let us do so below:

\begin{quote}
  To know $\type\alpha$ is to know what counts as an object of type $\alpha$,
  and when two such objects are equal.
\end{quote}

For now, we'll leave the question of what is an ``object'' as
abstract; in many cases, types will represent judgements of a logical
theory, and the objects will be the derivations (demonstrations,
proofs) of those judgements.

\begin{quote}
  To know $\etype{\alpha}{\beta}$ is to know that any object of type $\alpha$ is
  also an object of type $\beta$, and two equal objects of type $\alpha$ are
  equal as objects of type $\beta$ (necessarily presupposing \type\alpha\ and
  \type\beta).
\end{quote}

\begin{quote}
  To know $\ofty{M}{\alpha}$ is to know that $M$ is an object of type $\alpha$
  (necessarily presupposing $\type\alpha$).
\end{quote}

\begin{quote}
  To know $\eofty{M}{N}{\alpha}$ is to know that $M$ and $N$ are equal objects of type
  $\alpha$ (necessarily presupposing $\ofty{M}{\alpha}$ and $\ofty{N}{\alpha}$).
\end{quote}

Hypothetical judgement $\hyp{\mathcal{J}}{\mathcal{J}'}$ and general
judgement $\genj{x}{\mathcal{J}}$ have the same meaning in the logical
framework as before. In addition to these forms of judgement, we will
need contexts (with their wellformedness judgement $\isctx{\Gamma}$)
and an intensional sequent judgement
\framebox{$\lfsequent{\Gamma}{\mathcal{J}}$}; their meanings here will
be precisely the same as in the computational type theory, modulo the
fact that the intensional sequent judgement is defined over the
categorical judgements of the logical framework ($\type\alpha$,
$\etype{\alpha}{\beta}$, $\ofty{M}{\alpha}$ and $\eofty{M}{N}{\alpha}$).

At this point, we may begin adding types to the logical framework. In
practice, most types which we will introduce in the logical framework
will be defined in terms of a judgement of the logical theory which
lies below it.  For instance, hypothetical judgement in the logical
theory is represented by a function type in the logical framework,
$(x:\alpha)\beta$, whose typehood is meant to be evident under the
following circumstances
\[
  \infer{
    \type{(x:\alpha)\beta}
  }{
    \type\alpha &
    \lfsequent{x:\alpha}{\type\beta}
  }
\]
Or as a hypothetical judgement,
$\hyp{\type{(x:\alpha)\beta}}{\type\alpha,\lfsequent{x:\alpha}{\type\beta}}$.

Now, to know this judgement is to know that under the circumstances we
know what is an object of type $\alpha$ and when two such objects are
equal, and that if we have such an object $x$ of type $\alpha$, we
know what an object of type $\beta$ is, and when two such objects are
equal---then we know what an object of type $(x:\alpha)\beta$ is, and
moreover, for any two objects $y,z$ of type $\alpha$, that
$[y/x]\beta$ and $[z/x]\beta$ are equal as types. To make this
evident, then, we will say that under those circumstances an object of
type $(x:\alpha)\beta$ is an object $[x]M$ such that one knows
$\lfsequent{x:\alpha}{\ofty{M}{\beta}}$ and $\genj{x,y}{\hyp{\eofty{[y/x]M}{[z/x]M}{[y/x]\beta}}{\eofty{y}{z}{\alpha}}}$;
furthermore, two such objects are equal just when they yield equal
outputs for equal inputs.

Then, for each atomic proposition $P$, we can easily
define a type $\prf{P}$, as follows. Under the circumstances that
$\isprop{P}$ in the logical theory, then $\type{\prf{P}}$ in the
logical framework, since we will define an object of type $\prf{P}$ to
be a derivation of $\istrue{P}$; beyond reflexivity,
further definitional equalities can be added to reflect the harmony of
introduction and elimination rules.

Now, the definitions we have given for the types above are
``intuitively'' correct, but they actually fail to satisfy the meaning
explanation that we have given for $\type\alpha$, because they do not
take into account neutral terms. In the following sections, we will
investigate this problem in more detail and propose a solution.

\subsection{What is an ``object''?}
It is time to revisit what it means to be an ``object'' of a type in the
proof-theoretic type theory; we must note how this will necessarily differ from
what it meant to be a ``verification'' of a proposition in the previous
sections. Namely, a verification of a proposition is either a \emph{canonical
verification} of that proposition (and what sort of thing this might be is
known from the presupposition $\isprop{P}$), or it is a means of getting such
a canonical verification (i.e. a term which evaluates to a canonical
verification).

On the other hand, what we have called an ``object'' of type $P$ is quite
different, since in addition to the possibility that it is a canonical proof of
the judgement $\istrue{P}$, it may also be \emph{neutral} (i.e. blocked by a
variable); we will call this ``normal'' rather than ``canonical''. Why does
this happen?

In order to keep the judgement $\ofty{M}{A}$ analytic (decidable), its meaning
explanation can no longer be based on the idea of the computation of closed
terms to canonical form; instead, we will consider the computation of open
terms (i.e. terms with free variables) to \emph{normal} form. The desire for
$\ofty{M}{A}$ to be analytic follows from our intention that it characterize a
\emph{proof theory}: we must be able to recognize a proof when we see one. But
why are closed-term-based meaning explanations incompatible with this goal?
Consider briefly the following judgement:
\[
  \genj{n}{\hyp{\ver{M(n)}{P}}{\ver{n}{\naturals}}}
\]

To know this judgement is to know that $M(n)$ computes to a canonical
verification of $P$ whenever $n$ is a natural number; when $P$'s use of $n$ is
not trivial, this amounts to testing an infinite domain (all of the natural
numbers), probably by means of mathematical induction. The judgement is then
clearly synthetic: to know it is, briefly, to have come up with an (inductive)
argument that $M(N)$ computes to a canonical verification of $P$ at each
natural number $n$.

On the other hand, the judgement $\lfsequent{n:\naturals}{\ofty{M(n)}{P}}$ must have a
different meaning, one which admits its evidence or refutation purely on
syntactic/analytic grounds. In essence, it is to know that $M(n)$ is a proof of
$P$ for any \emph{arbitrary} object/expression $n$ such that $\ofty{n}{\naturals}$
(i.e., the only thing we know about $n$ is that it is of type $\naturals$; we
do not necessarily know that it is a numeral).


\section{A critique of \textbf{MLLF}}

The type theory which we constructed in the previous section is to be
considered a proof theory for a logic with the judgements
$\isprop{P}$, $\istrue{P}$ and
$\hyp{\mathcal{J}}{\mathcal{J}'}$. There are a few reasons to be
dissatisfied with this state of affairs, which I shall enumerate in
this section.

\subsection{Lack of computational content}

Unlike the type theory in the first chapter, there is no built-in computational
content. In a computational type theory which is defined by the verificationist
meaning explanations, the computational content of terms is understood
immediately by means of the $\reduce{M}{M'}$ relation; that is, computation is
prior to the main judgements because their meaning explanations are defined in
terms of evaluation to canonical form.

On the other hand, in the type theory above we did not give a
primitive reduction relation; instead, we simply permitted the
endowement of proofs with definitional equalities which reflect the
harmony of introduction and elimination rules. That is, if we have
known the judgement $\istrue{P}$ by means of an indirect argument
(derivation), it must be the case that this derivation corresponds to
a direct one; we reflect this in the proof theory by defining the
indirect derivation to be definitionally equal to the direct one.

However, this does not amount to computational content being present in terms:
only \emph{post facto} may the definitional equality be construed as giving
rise to computation, through a metamathematical argument which shows that the
definitional equality is confluent and can be used to define a functional
normalization relation.

And this is the reason for the peculiarity of the proof-theoretic
meaning explanations, namely that they do not include phrases like
``evaluates to a canonical...'', since evaluation may only be
understood after taking the meanings of the judgements ($\type\alpha$,
$\etype{\alpha}{\beta}$, $\ofty{M}{\alpha}$, $\eofty{M}{N}{\alpha}$) as giving rise to a
closed formal system which is susceptible to metamathematical
argument: to refer to evaluation in the meaning explanations for the
core judgements, then, would be impredicative.

\subsection{Modularity of definition}

By the same token, the distinction between canonical (direct) and non-canonical
(indirect) proof may not be understood as a core notion in the theory, but must
be understood separately, secondarily. Why is this a problem? It means that the
definition of each type must be made with the full knowledge of the definitions
of every other type; in essence, the open-ended nature of type theory is
obliterated and one is forced into a fixed formal system; this is in addition
to the fact that it causes the epistemic content of $\type\alpha$ for any type
$\alpha$ to be extremely complicated.

To illustrate, let us consider as an example a type theory which has
four type-formers: trivial truth $\top$, trivial falsity $\bot$,
implication $(\alpha)\beta$, and conjunction $\product\alpha\beta$; we
will then introduce the following terms to represent proofs: the
trivial element $\bullet$, \emph{reductio ad absurdum}
$\abort{\alpha}{E}$, abstraction $[x:\alpha]E$, application $E(E')$,
pairing $\pair{E}{E'}$, and projections $\fst{E}$, $\snd{E}$.

If we will try to make the judgement $\type\top$ evident, the deficiencies of
the formulation will immediately present themselves.

\begin{quote}
To know $\type\top$ is to know what counts as an object of type $\top$, and when
two such objects are equal. An object of type $\top$, then, is either the
expression $\bullet$, or an expression $\abort{\top}{E}$ such that we know
$\ofty{E}{\bot}$, or an expression $E(E')$ such that we know $\ofty{E}{(\alpha)\top}$ and
$\ofty{E'}{\alpha}$, or an expression $\fst{E}$ such that we know $\ofty{E}{\product\top\beta}$
for some $\beta$, or an expression $\snd{E}$ such that we know
$\ofty{E}{\product\alpha\top}$ for some $\alpha$; and we additionally have that $\bullet$
is equal to $\bullet$, and ...
\end{quote}

To save space, we elide the rest of the definition of equality for $\top$; what
we have seen so far already suffices to bring to light a serious problem: the
definition of any type requires knowledge of the entire syntax of the theory.
The judgement $\type\alpha$ may never be made evident in isolation, but must be
done with full understanding of all the other types and their definitions.

Furthermore, to extend an existing theory with a new type, the definitions of
every other type must be rewritten to account for the elimination forms of the
new type.

\end{document}
